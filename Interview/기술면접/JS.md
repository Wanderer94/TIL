### Express란?

<details>
  <summary>답변 보기</summary>

Express는 Node.js에서 사용하는 경량화된 웹 애플리케이션 프레임워크로, HTTP 서버를 간단하게 설정하고, 다양한 요청과 응답을 처리하는 미들웨어를 제공합니다.

</details>

### NestJS의 구조?

<details>
  <summary>답변 보기</summary>

NestJS는 모듈, 컨트롤러, 서비스, 프로바이더 등으로 구성되며, 모듈화와 DI를 활용해 서비스 간 의존성을 관리합니다.

</details>

### DI와 IoC란?

<details>
  <summary>답변 보기</summary>

DI는 의존성을 외부에서 주입하는 방식이고, IoC는 제어의 흐름을 프레임워크가 담당하는 개념입니다.

</details>

### Express와 NestJS의 차이점?

<details>
  <summary>답변 보기</summary>

Express는 경량화된 자유로운 구조, NestJS는 모듈화와 DI를 기본으로 하여 더 복잡한 애플리케이션 구조에 적합합니다.

</details>

### Rest API란?

<details>
  <summary>답변 보기</summary>

REST API는 자원의 상태를 HTTP 메서드를 통해 처리하는 API입니다.

</details>

### Rest API에서 'rest'란?

<details>
  <summary>답변 보기</summary>

'REST'는 Representational State Transfer의 약자로, 자원의 표현과 상태를 전송하는 것을 의미합니다.

</details>

### 변수의 생성과정과 호이스팅에 대해 설명해라

<details>
  <summary>답변 보기</summary>

변수는 선언, 초기화, 할당의 단계를 거치며, 자바스크립트에서 호이스팅은 선언이 코드 상단으로 끌어올려지는 동작을 합니다.

</details>

### 변수의 생성과정

<details>
  <summary>답변 보기</summary>

변수는 선언 후 초기화되고, 그 후 할당이 이루어집니다.

</details>

### 호이스팅이란?

<details>
  <summary>답변 보기</summary>

호이스팅은 변수나 함수 선언이 코드 상단으로 끌어올려지는 자바스크립트의 동작 방식을 의미합니다.

</details>

### let,var,const의 차이점

<details>
  <summary>답변 보기</summary>

var는 함수 스코프, let과 const는 블록 스코프를 가집니다. const는 재할당이 불가능합니다.

</details>

### 함수 스코프와 블록 스코프란?

<details>
  <summary>답변 보기</summary>

함수 스코프는 함수 내에서만 접근 가능한 변수의 범위를, 블록 스코프는 블록 내에서만 유효한 변수를 의미합니다.

</details>

### 동기와 비동기?

<details>
  <summary>답변 보기</summary>

동기는 순차적으로 실행되고, 비동기는 병렬적으로 실행되어 이전 작업이 완료되지 않아도 다음 작업이 진행됩니다.

</details>

### Promise의 특징과 Async/Await특징?

<details>
  <summary>답변 보기</summary>

Promise는 비동기 작업의 결과를 처리하며, Async/Await는 비동기 작업을 동기 코드처럼 작성할 수 있게 도와줍니다.

</details>

### Const를 사용했을 때, 값을 변경할 수 있는 상황은?

<details>
  <summary>답변 보기</summary>

const로 선언된 객체나 배열의 내부 속성은 변경될 수 있습니다.

</details>

### 타입스크립트의 장점?

<details>
  <summary>답변 보기</summary>

타입스크립트는 정적 타입 체크를 제공해 코드의 안전성과 유지보수성을 높입니다.

</details>

### struct와 class의 차이는 무엇인가요?

<details>
  <summary>답변 보기</summary>

struct는 값 타입이고, class는 참조 타입입니다.

</details>

### AlarmManager의 setAlarmClock() 메소드의 문제점은?

<details>
  <summary>답변 보기</summary>

setAlarmClock() 메소드는 배터리 소모가 클 수 있습니다.

</details>

### RecyclerView의 ViewHolder를 사용했을 때의 장점은?

<details>
  <summary>답변 보기</summary>

ViewHolder 패턴은 성능과 메모리 효율성을 높여줍니다.

</details>

### 최근에 가장 관심있는 기술이 있다면 무엇인가요?

<details>
  <summary>답변 보기</summary>

개인적으로 최근에 관심있는 기술을 이야기하세요.

</details>

### 메모리 구조에 대해 설명해 주세요.

<details>
  <summary>답변 보기</summary>

메모리는 스택, 힙, 데이터, 코드 영역으로 나뉘며, 각각의 용도가 다릅니다.

</details>

### 코루틴에 대해 스레드 관점에서 설명해주세요

<details>
  <summary>답변 보기</summary>

코루틴은 경량화된 스레드로 비동기 작업을 효율적으로 처리합니다.

</details>

### 레거시 코드는 반드시 고쳐야하는지? 상사가 레거시 코드를 고집한다면?

<details>
  <summary>답변 보기</summary>

레거시 코드는 반드시 고쳐야 하는 것은 아니지만, 유지보수와 확장성에 문제가 있다면 개선해야 합니다.

</details>

### Context에 대해 설명해주세요, 액티비티 내에서 this가 무엇을 의미하는지?

<details>
  <summary>답변 보기</summary>

Context는 애플리케이션의 현재 상태에 대한 정보를 제공하며, 액티비티 내에서 this는 현재 액티비티의 인스턴스를 의미합니다.

</details>

### Rest api의 특징 중 아는 것을 말해보시오

<details>
  <summary>답변 보기</summary>

REST API는 상태가 없으며, 자원을 HTTP 메서드를 통해 접근합니다.

</details>

### 자바와 파이썬의 차이는 무엇인지 말해보세요(JS, TS의 차이에 대해서 + c와 c++ 그리고 다른 언어와의 차이)

<details>
  <summary>답변 보기</summary>

자바는 정적 타입 언어, 파이썬은 동적 타입 언어로 각각 성능과 간결성에 차이가 있습니다. JS는 동적 타입이고, TS는 정적 타입을 추가한 언어입니다. C는 절차지향, C++은 객체지향을 지원합니다.

</details>

### 클린 아키텍쳐는 무엇인지 설명할 수 있나요?

<details>
  <summary>답변 보기</summary>

클린 아키텍처는 비즈니스 로직과 외부 시스템의 의존성을 분리하는 아키텍처 패턴입니다.

</details>

---

### 동기와 비동기란 무엇인가요?

<details>
  <summary>답변 보기</summary>

**동기(Synchronous)**와 **비동기(Asynchronous)**는 작업을 수행하는 방식의 차이를 설명합니다.

- **동기(Synchronous):**

  - 동기 작업은 **순차적으로 수행**되며, 이전 작업이 완료될 때까지 다음 작업을 기다립니다.
  - 즉, 한 작업이 끝나야 다음 작업을 시작할 수 있습니다.
  - 예를 들어, 자바스크립트에서 다음 코드는 동기적으로 실행됩니다:

    ```javascript
    console.log("1");
    console.log("2");
    console.log("3");
    ```

    이 코드는 순서대로 "1", "2", "3"이 출력됩니다.

- **비동기(Asynchronous):**

  - 비동기 작업은 **다음 작업을 기다리지 않고** 동시에 실행될 수 있습니다.
  - 즉, 한 작업이 완료되기 전에 다른 작업을 계속 진행할 수 있습니다.
  - 비동기 작업의 예로는 네트워크 요청, 파일 읽기, 타이머 등이 있습니다.
  - 자바스크립트에서 비동기 작업을 처리하기 위해 **콜백 함수**, **Promise**, **Async/Await** 등을 사용할 수 있습니다.

    ```javascript
    console.log("1");
    setTimeout(() => {
      console.log("2");
    }, 1000);
    console.log("3");
    ```

    이 코드는 "1", "3"이 먼저 출력되고, 1초 후에 "2"가 출력됩니다.

</details>

---

### Promise의 특징과 Async/Await의 특징은 무엇인가요?

<details>
  <summary>답변 보기</summary>

**Promise**와 **Async/Await**는 비동기 작업을 처리하기 위한 방법입니다.

- **Promise:**

  - **Promise**는 비동기 작업의 **결과를 나타내는 객체**입니다. 비동기 작업이 성공적으로 완료되면 `resolve` 상태가 되고, 실패하면 `reject` 상태가 됩니다.
  - **Promise의 상태:**
    - **Pending:** 작업이 아직 완료되지 않은 상태.
    - **Fulfilled:** 작업이 성공적으로 완료된 상태.
    - **Rejected:** 작업이 실패한 상태.
  - **체이닝:** `.then()`과 `.catch()`를 사용하여 **비동기 작업의 결과를 처리**하거나 **에러를 처리**할 수 있습니다.

    ```javascript
    new Promise((resolve, reject) => {
      setTimeout(() => resolve("Success"), 1000);
    })
      .then((result) => {
        console.log(result); // "Success"
      })
      .catch((error) => {
        console.log(error);
      });
    ```

- **Async/Await:**

  - **Async/Await**는 **Promise를 사용하는 문법적 설탕**으로, 비동기 작업을 **동기적 코드처럼** 작성할 수 있도록 도와줍니다.
  - **async** 키워드를 함수 앞에 붙이면 해당 함수는 항상 **Promise를 반환**하며, **await** 키워드를 사용하여 Promise의 결과를 기다릴 수 있습니다.
  - **await**는 **Promise가 완료될 때까지** 함수의 실행을 중지합니다. 하지만 **await는 오직 async 함수 내에서만 사용할 수 있습니다**.

    ```javascript
    async function fetchData() {
      try {
        const result = await new Promise((resolve, reject) => {
          setTimeout(() => resolve("Success"), 1000);
        });
        console.log(result); // "Success"
      } catch (error) {
        console.log(error);
      }
    }

    fetchData();
    ```

  **Async/Await**는 비동기 작업을 **더 직관적이고 읽기 쉽게** 만들어줍니다.

</details>

---

### Const를 사용했을 때, 값을 변경할 수 있는 상황은 무엇인가요?

<details>
  <summary>답변 보기</summary>

**`const`**로 선언한 변수는 **재할당이 불가능**하지만, 변수의 **값이 객체인 경우**는 예외입니다. 즉, `const`로 선언된 변수에 **객체, 배열 등의 값을 할당**할 때, 변수 자체는 재할당할 수 없지만, 객체의 **속성이나 배열의 요소**는 변경할 수 있습니다.

- **기본형 데이터 (예: 숫자, 문자열, 불리언 등):** `const`로 선언된 기본형 데이터는 재할당할 수 없습니다.

  ```javascript
  const x = 10;
  // x = 20; // TypeError: Assignment to constant variable.
  ```

- **객체와 배열:** 객체나 배열은 `const`로 선언해도 **객체의 속성이나 배열의 요소는 변경**할 수 있습니다.

  ```javascript
  const obj = { name: "Alice" };
  obj.name = "Bob"; // OK
  console.log(obj.name); // "Bob"

  const arr = [1, 2, 3];
  arr.push(4); // OK
  console.log(arr); // [1, 2, 3, 4]
  ```

  하지만, 변수 자체에 대한 재할당은 여전히 불가능합니다.

  ```javascript
  obj = { name: "Charlie" }; // TypeError: Assignment to constant variable.
  arr = [5, 6, 7]; // TypeError: Assignment to constant variable.
  ```

결론적으로, `const`는 **변수의 재할당을 방지**하지만, 객체나 배열의 **내부 상태는 변경할 수 있습니다**.

</details>

---

### 타입스크립트의 장점은 무엇인가요?

<details>
  <summary>답변 보기</summary>

**타입스크립트(TypeScript)**는 **자바스크립트의 상위 집합**으로, 자바스크립트에 **정적 타입 검사**와 **타입 시스템**을 추가한 언어입니다. 타입스크립트의 주요 장점은 다음과 같습니다:

- **정적 타입 검사:** 타입스크립트는 **코드를 컴파일할 때 타입 검사를 수행**하여, 런타임 에러를 사전에 방지할 수 있습니다. 이는 코드의 안정성을 높이고, 버그를 줄이는 데 도움을 줍니다.

  ```typescript
  let num: number = 10;
  num = "string"; // TypeError: Type 'string' is not assignable to type 'number'.
  ```

- **타입 추론:** 타입스크립트는 **타입 추론**을 통해, 명시적으로 타입을 지정하지 않아도 **변수의 타입을 자동으로 추론**할 수 있습니다.

  ```typescript
  let message = "Hello"; // TypeScript infers the type as 'string'
  ```

- **객체 지향 프로그래밍 지원:** 타입스크립트는 **클래스, 인터페이스, 제네릭** 등 **객체 지향 프로그래밍 패턴**을 지원하여, **복잡한 애플리케이션을 더 쉽게 관리**할 수 있습니다.

- **IDE 지원:** 타입스크립트는 **자동 완성, 코드 네비게이션, 리팩토링** 등 **IDE의 강력한 지원**을 제공합니다. 이는 개발자의 생산성을 높이는 데 도움을 줍니다.

- **모듈 시스템:** 타입스크립트는 **ES6 모듈 시스템**을 지원하며, **모듈화된 코드를 작성**하여, 코드의 재사용성과 유지보수성을 높일 수 있습니다.

- **JavaScript와 호환:** 타입스크립트는 **자바스크립트와 완벽하게 호환**되며, 기존의 자바스크립트 코드와 함께 사용할 수 있습니다. 타입스크립트로 작성된 코드는 **자바스크립트로 컴파일**되어 실행됩니다.

결론적으로, 타입스크립트는 **코드의 안정성을 높이고, 개발 효율성을 개선**하며, **객체 지향 프로그래밍을 지원**하는 강력한 도구입니다.

</details>

---

### struct와 class의 차이는 무엇인가요?

<details>
  <summary>답변 보기</summary>

**Struct**와 **Class**는 프로그래밍 언어에서 **데이터를 구조화**하고 **객체를 생성**하기 위한 개념입니다. 이 두 개념의 주요 차이점은 다음과 같습니다:

- **Struct (구조체):**

  - **값 타입(Value Type):** 구조체는 **값 타입**으로, 구조체의 인스턴스는 변수에 직접 저장됩니다. 구조체를 다른 변수에 할당하면, 새로운 인스턴스가 생성됩니다.
  - **메모리 할당:** 구조체는 **스택 메모리**에 할당됩니다.
  - **상속:** 구조체는 상속을 지원하지 않으며, 다른 구조체에서 파생될 수 없습니다.
  - **기본 생성자:** 대부분의 언어에서 구조체는 **기본 생성자**가 자동으로 제공되며, 사용자가 추가 생성자를 정의할 필요가 없습니다.

  ```cpp
  struct Point {
    int x;
    int y;
  };

  Point p1 = {10, 20}; // 구조체 인스턴스 생성
  ```

- **Class (클래스):**
  - \*\*참

조 타입(Reference Type):** 클래스는 **참조 타입\*\*으로, 클래스의 인스턴스는 변수에 참조로 저장됩니다. 클래스를 다른 변수에 할당하면, 동일한 인스턴스를 참조하게 됩니다.

- **메모리 할당:** 클래스는 **힙 메모리**에 할당됩니다.
- **상속:** 클래스는 **상속**을 지원하며, 다른 클래스를 기반으로 파생 클래스를 만들 수 있습니다.
- **접근 제어:** 클래스는 **접근 제어자**(예: `public`, `private`, `protected`)를 사용하여 **멤버에 대한 접근 권한을 제어**할 수 있습니다.
- **추상화:** 클래스는 **추상화**와 **캡슐화**를 지원하며, 복잡한 데이터 구조와 행동을 정의할 수 있습니다.

```cpp
class Point {
  public:
    int x;
    int y;
};

Point p1; // 클래스 인스턴스 생성
p1.x = 10;
p1.y = 20;
```

결론적으로, **구조체는 값 타입**으로 메모리 관리가 간단하고, **클래스는 참조 타입**으로 더 많은 기능을 지원하며 상속과 접근 제어를 활용할 수 있습니다.

</details>

---

### AlarmManager의 setAlarmClock() 메소드의 문제점은 무엇인가요?

<details>
  <summary>답변 보기</summary>

**AlarmManager의 `setAlarmClock()`** 메소드는 **알람을 설정**하는 데 사용되는 메소드입니다. 이 메소드의 주요 문제점은 다음과 같습니다:

- **호환성 문제:** `setAlarmClock()` 메소드는 **API 레벨 23 (Android 6.0)** 이상에서만 사용 가능하며, 이전 버전의 안드로이드에서는 사용할 수 없습니다. 따라서, **낮은 API 레벨을 지원**해야 하는 앱에서는 대체 방법을 사용해야 합니다.

- **배터리 소모:** 이 메소드를 사용하여 설정된 알람은 **배터리 소모**를 유발할 수 있습니다. 알람이 설정된 시간에 디바이스가 절전 모드에 들어가면 알람이 지연될 수 있습니다.

- **정확도 문제:** `setAlarmClock()`을 사용하여 설정한 알람은 **정확한 시간에 알람을 울리도록 보장**하지 않습니다. 시스템의 절전 모드나 기타 전력 관리 설정에 따라 알람이 정확히 맞지 않을 수 있습니다.

- **앱의 제어 부족:** 알람이 시스템에서 처리되기 때문에, **앱이 알람의 실행을 직접 제어하거나 확인**할 수 없습니다. 알람의 정확성과 실행에 대해 앱이 전적으로 의존해야 합니다.

- **사용자 알림:** `setAlarmClock()` 메소드는 **앱의 UI**를 통해 사용자가 알람을 설정할 수 있게 하며, 사용자가 설정을 취소할 수도 있습니다. 따라서 앱의 알람이 의도대로 작동하지 않을 수 있습니다.

결론적으로, `setAlarmClock()` 메소드는 **호환성, 배터리 소모, 정확도** 등의 문제점을 가지고 있으며, 이를 고려하여 적절한 방법으로 알람을 설정해야 합니다.

</details>

---

### RecyclerView의 ViewHolder를 사용했을 때의 장점은 무엇인가요?

<details>
  <summary>답변 보기</summary>

**RecyclerView의 ViewHolder**는 **효율적인 목록 아이템 재사용**과 **성능 최적화**를 위해 사용되는 디자인 패턴입니다. ViewHolder를 사용할 때의 주요 장점은 다음과 같습니다:

- **성능 향상:** ViewHolder 패턴은 **아이템 뷰의 재사용**을 가능하게 하여, **뷰의 인플레이션과 바인딩 작업**을 최소화합니다. 이는 **스크롤 성능을 개선**하고, 앱의 전반적인 반응성을 높입니다.

- **뷰 재사용:** RecyclerView는 스크롤할 때 화면에 보이는 아이템만을 인플레이션하고, **화면에서 사라진 아이템의 뷰를 재사용**합니다. 이를 통해 메모리와 성능을 효율적으로 관리할 수 있습니다.

- **코드 간결성:** ViewHolder를 사용하면, 뷰를 찾는 코드가 **어댑터의 `onBindViewHolder()` 메소드** 내에서 한 번만 실행됩니다. 이로 인해 코드가 간결하고 유지보수가 쉬워집니다.

- **아이템 뷰의 캐시:** ViewHolder는 **아이템 뷰의 참조를 캐시**하여, 매번 `findViewById()`를 호출할 필요가 없게 합니다. 이는 **성능을 향상**시키고 **뷰 검색 시간을 줄입니다**.

- **뷰 상태 유지:** ViewHolder는 뷰의 상태를 유지하며, **스크롤 시 뷰의 상태를 잃지 않도록** 도와줍니다. 이로 인해 스크롤 시 뷰가 올바르게 업데이트됩니다.

- **일관된 데이터와 뷰:** ViewHolder를 사용하면, 데이터와 뷰가 **일관성 있게 바인딩**되며, **데이터 변경 시 뷰의 업데이트**가 더 용이해집니다.

결론적으로, ViewHolder 패턴은 **성능 최적화, 메모리 관리, 코드 간결성** 등을 통해 **RecyclerView의 효율성을 높이는 데** 중요한 역할을 합니다.

</details>

---

### 최근에 가장 관심있는 기술이 있다면 무엇인가요?

<details>
  <summary>답변 보기</summary>

최근에 **인공지능(AI)**와 **기계학습(ML)**에 대한 관심이 큽니다. 특히 **대화형 AI, 자연어 처리(NLP)** 및 **지능형 자동화**와 같은 분야에 흥미를 가지고 있습니다. 이러한 기술들은 **비즈니스 및 개인 생활에 미치는 영향**이 크며, **데이터 분석** 및 **자동화**를 통해 효율성을 극대화할 수 있는 가능성을 가지고 있습니다.

최근에는 **Generative AI**와 **딥러닝**을 활용하여 **텍스트 생성, 이미지 생성** 및 **모델 학습**에 대해 연구하고 있습니다. 또한, **AI와 ML을 결합한 혁신적인 애플리케이션**의 개발 가능성을 탐구하고 있으며, 이를 통해 **실제 문제 해결**에 기여하고자 합니다.

</details>

---

### 메모리 구조에 대해 설명해 주세요.

<details>
  <summary>답변 보기</summary>

**메모리 구조**는 컴퓨터 시스템에서 **메모리를 어떻게 조직**하고 **관리**하는지를 설명합니다. 주요 메모리 구조는 다음과 같습니다:

- **메인 메모리 (RAM):**

  - **임시 저장공간**으로, 컴퓨터가 실행 중인 프로그램과 데이터를 저장합니다. RAM은 **휘발성 메모리**로, 전원이 꺼지면 데이터가 사라집니다.
  - **주소 공간**으로 구분되며, **프로그램과 데이터**가 메모리 주소에 따라 저장됩니다.

- **캐시 메모리:**

  - **CPU와 메인 메모리 사이**에 위치하며, **자주 사용되는 데이터와 명령어**를 저장하여 **속도**를 향상시킵니다.
  - **L1, L2, L3 캐시**로 구분되며, L1 캐시는 **가장 빠르고 작은** 캐시로, L3 캐시는 **가장 느리지만 큰** 캐시입니다.

- **가상 메모리:**

  - **물리적 메모리**와 **디스크 공간**을 결합하여 **프로세스가 사용할 수 있는 메모리 용량**을 확장합니다.
  - **페이지 파일** 또는 **스와프 파일**을 사용하여 **메인 메모리가 부족할 때** 데이터를 저장합니다.

- **ROM (Read-Only Memory):**

  - **비휘발성 메모리**로, **시스템 부팅에 필요한 펌웨어**나 **기본 입력/출력 시스템(BIOS)**을 저장합니다.
  - **읽기 전용**으로, 일반적으로 **데이터를 수정할 수 없습니다**.

- **레지스터:**

  - **CPU 내에 위치**하며, **가장 빠른 메모리**입니다. **연산 결과**나 **주소**를 저장합니다.
  - **작업의 중간 결과**를 저장하거나 **명령어를 디코딩**하는 데 사용됩니다.

- **힙과 스택:**
  - **스택**은 **함수 호출** 및 **지역 변수**의 메모리를 관리합니다. **LIFO(Last In, First Out)** 방식으로 작동합니다.
  - **힙**은 **동적으로 할당된 메모리**를 관리하며, **메모리 할당과 해제**가 자유롭습니다.

결론적으로, 메모리 구조는 **속도, 용량, 휘발성** 등의 다양한 측면을 고려하여 **효율적인 데이터 관리와 접근**을 가능하게 합니다.

</details>

---

### 코루틴에 대해

스레드 관점에서 설명해주세요.

<details>
  <summary>답변 보기</summary>

**코루틴(Coroutine)**은 **비동기 프로그래밍**에서 **비동기 작업**을 수행하는 **경량 스레드**입니다. 스레드 관점에서 코루틴의 주요 특징은 다음과 같습니다:

- **경량성:** 코루틴은 **스레드보다 더 가볍**고, 스레드보다 **적은 리소스**를 소모합니다. 스레드는 메모리와 관리 오버헤드가 크지만, 코루틴은 **작고 빠른 전환**을 제공합니다.

- **협업적 스케줄링:** 코루틴은 **협업적 스케줄링**을 사용하여, **스레드와 달리 직접 스케줄러와의 상호작용** 없이 **전환**됩니다. 코루틴은 **명시적으로 중단**하고 다시 시작할 수 있습니다.

- **컨텍스트 스위칭:** 스레드는 **운영체제에 의해 관리**되는 반면, 코루틴은 **사용자 레벨에서 관리**됩니다. 따라서, 코루틴의 **컨텍스트 스위칭은 빠르고 효율적**입니다.

- **상태 유지:** 코루틴은 **실행 상태를 유지**하며, **중단된 지점에서 다시 시작**할 수 있습니다. 이는 **비동기 작업의 중간 상태**를 저장하고, **비동기 작업이 완료될 때까지** 기다릴 수 있게 합니다.

- **동시성:** 코루틴은 **동시성**을 지원하며, **동시에 여러 작업을 실행**할 수 있습니다. 이는 **비동기 작업**의 효율적인 관리를 가능하게 합니다.

- **스레드와의 차이점:** 스레드는 **운영체제에 의해 스케줄링**되고, **병렬 처리**를 지원합니다. 반면, 코루틴은 **단일 스레드 내에서 비동기 작업**을 처리하며, **멀티스레딩**을 사용하지 않습니다.

결론적으로, 코루틴은 **스레드보다 효율적**으로 **비동기 작업을 관리**하며, **경량성**과 **빠른 컨텍스트 스위칭**을 통해 **비동기 프로그래밍의 성능을 향상**시킵니다.

</details>

---

### 레거시 코드는 반드시 고쳐야하는지? 상사가 레거시 코드를 고집한다면?

<details>
  <summary>답변 보기</summary>

**레거시 코드**는 **기존 시스템**에서 오랜 시간 동안 사용된 코드를 말합니다. 레거시 코드를 **고쳐야 하는지**와 **상사가 레거시 코드를 고집할 때의 대처 방법**은 다음과 같습니다:

- **레거시 코드 고쳐야 하는 이유:**

  - **보안 문제:** 오래된 코드에는 **보안 취약점**이 있을 수 있으며, 이를 수정하지 않으면 **보안 위험**이 발생할 수 있습니다.
  - **유지보수 어려움:** 레거시 코드는 **문서화가 부족**하거나 **코드가 복잡**할 수 있어, **유지보수가 어렵**고 **버그 수정**이 힘들 수 있습니다.
  - **기술 발전:** 새로운 **프레임워크**나 **기술**이 발전하면서, 레거시 코드는 **업데이트된 기술에 비해 효율이 떨어질** 수 있습니다.
  - **성능:** 레거시 코드는 **성능 문제**를 일으킬 수 있으며, **최신 기술**로 개선할 경우 **성능을 향상**시킬 수 있습니다.

- **상사가 레거시 코드를 고집하는 경우:**
  - **타당한 이유 이해:** 상사가 레거시 코드를 고집하는 이유를 **이해하고**, **기술적, 비즈니스적** 이유를 파악합니다.
  - **문서화:** 레거시 코드의 **문서화를 개선**하고, **코드의 이해를 돕기 위한 문서**를 작성합니다.
  - **점진적 개선:** 전체 시스템을 한 번에 변경하기보다는, **점진적으로 레거시 코드를 개선**하거나 **모듈 단위로 리팩토링**합니다.
  - **위험 분석:** 레거시 코드를 변경할 때의 **위험과 장점**을 분석하여, **상사에게 효과적인 리팩토링 전략**을 제시합니다.
  - **테스트 작성:** 변경 전에 **철저한 테스트**를 작성하여, 레거시 코드의 **기능을 보장**합니다.

결론적으로, 레거시 코드는 **성능, 보안, 유지보수성** 측면에서 **개선이 필요**할 수 있으며, 상사와 협력하여 **효율적인 개선 전략**을 수립하는 것이 중요합니다.

</details>

---

### Context에 대해 설명해 주세요. 액티비티 내에서 this가 무엇을 의미하는지?

<details>
  <summary>답변 보기</summary>

**Context**는 **안드로이드 애플리케이션**에서 **환경 정보**와 **리소스에 대한 액세스**를 제공하는 클래스입니다. 주요 사항은 다음과 같습니다:

- **Context:**

  - **애플리케이션의 환경**을 정의하며, **리소스, 테마, 데이터베이스**, 그리고 **시스템 서비스**에 대한 접근을 제공합니다.
  - **두 가지 주요 종류:** `Activity`의 `Context`, `Application`의 `Context`가 있습니다.
    - `Activity`의 `Context`는 **액티비티의 상태**와 **UI 관련 작업**을 처리하는 데 사용됩니다.
    - `Application`의 `Context`는 **애플리케이션 전반**에 대한 정보를 제공하며, **애플리케이션의 생애 주기**와 관련된 작업을 처리합니다.

- **액티비티 내에서 `this`의 의미:**

  - **`this`**는 현재 **액티비티의 인스턴스**를 참조합니다.
  - **현재 액티비티의 `Context`**를 나타내며, 액티비티의 **UI 요소**나 **리소스**에 접근할 수 있습니다.
  - 예를 들어, `this.findViewById()`를 사용하여 **UI 요소**에 접근하거나, `this.getSystemService()`를 통해 **시스템 서비스**를 요청할 수 있습니다.

  ```java
  public class MainActivity extends AppCompatActivity {
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);

          // 'this'는 현재 액티비티를 참조
          Button myButton = this.findViewById(R.id.my_button);
      }
  }
  ```

  이 경우, `this`는 `MainActivity`의 인스턴스를 참조하며, 액티비티의 **뷰를 조작**하거나 **시스템 서비스를 사용할** 때 유용합니다.

결론적으로, `Context`는 안드로이드 애플리케이션에서 **환경과 리소스에 접근**하는 데 사용되며, 액티비티 내에서 `this`는 **현재 액티비티의 인스턴스**를 참조합니다.

</details>

---

### Rest API의 특징 중 아는 것을 말해보세요.

<details>
  <summary>답변 보기</summary>

**REST API (Representational State Transfer API)**는 **웹 서비스**를 설계하기 위한 아키텍처 스타일입니다. 주요 특징은 다음과 같습니다:

- **무상태성 (Stateless):**

  - REST API는 **서버가 클라이언트의 상태를 저장하지 않도록** 설계됩니다. 각 요청은 **독립적**이며, **필요한 모든 정보**를 요청에 포함해야 합니다.
  - 서버는 **요청 간의 상태를 유지하지 않으며**, 클라이언트가 필요한 모든 정보를 **요청에 포함**해야 합니다.

- **자원 지향 (Resource-Oriented):**

  - REST API는 **자원**을 중심으로 설계됩니다. 각 자원은 **URI(Uniform Resource Identifier)**로 식별됩니다.
  - 예를 들어, `/users`, `/orders`와 같은 URI를 사용하여 **특정 자원**에 접근합니다.

- **HTTP 메소드:**

  - REST API는 **표준 HTTP 메소드**를 사용하여 자원을 조작합니다.
    - **GET:** 자원 조회
    - **POST:** 자원 생성
    - **PUT:** 자원 전체 수정
    - **PATCH:** 자원 부분 수정
    - **DELETE:** 자원 삭제

- **표현 (Representation):**

  - 자원은 다양한 형식으로 표현될 수 있으며, **JSON**이나 **XML** 형식으로 클라이언트와 서버 간에 데이터가 전송됩니다.
  - 클라이언트는 원하는 표현 형식을 **Accept** 헤더를 통해 지정할 수 있습니다.

- **캐싱 (Caching):**
  - REST API는 **HTTP 캐싱**을 활용하여 **성능을 향상**시키고, 서버의 \*\*부하를 줄일 수

있습니다\*\*.

- 적절한 캐시 제어 헤더를 사용하여 **자원**의 **캐싱을 제어**할 수 있습니다.

* **계층화 (Layered System):**

  - REST API는 **계층화된 아키텍처**를 지원하며, **중간 서버**나 **프록시**를 통해 **부하 분산**이나 **보안 강화**를 할 수 있습니다.
  - 클라이언트는 **중간 서버의 존재**를 인식하지 못하고, **최종 서버**와만 상호작용합니다.

* **인터페이스 일관성 (Uniform Interface):**
  - REST API는 **일관된 인터페이스**를 통해 자원에 접근할 수 있으며, 이는 **표준화된 방식**으로 자원 조작을 가능하게 합니다.
  - **자원의 명확한 식별**, **표준 HTTP 메소드 사용**, **자원의 표현**을 통해 일관된 방식으로 API를 설계합니다.

결론적으로, REST API는 **무상태성, 자원 지향**, **HTTP 메소드 사용** 등의 특징을 통해 **웹 서비스의 효율적이고 표준화된 설계**를 제공합니다.

</details>

---

### 자바와 파이썬의 차이는 무엇인지 말해보세요(JS, TS의 차이에 대해서 + c와 c++ 그리고 다른 언어와의 차이).

<details>
  <summary>답변 보기</summary>

**자바(Java)**와 **파이썬(Python)**은 **서로 다른 특성**을 가진 두 가지 인기 있는 프로그래밍 언어입니다. 주요 차이점은 다음과 같습니다:

- **자바 (Java):**

  - **정적 타이핑 (Static Typing):** 자바는 **정적 타입 언어**로, 변수의 타입을 **컴파일 타임**에 정의합니다. 이는 **형 변환 오류를 사전에 방지**할 수 있게 해줍니다.
  - **컴파일 언어:** 자바 코드는 **바이트코드**로 컴파일되어, **JVM (Java Virtual Machine)**에서 실행됩니다.
  - **객체 지향:** 자바는 **객체 지향 프로그래밍** 언어로, 모든 것이 **클래스와 객체**로 구성됩니다.
  - **병렬 처리:** 자바는 **멀티스레딩**을 지원하며, **스레드 기반**의 병렬 처리를 제공합니다.
  - **다중 상속 제한:** 자바는 **클래스의 다중 상속을 지원하지** 않으며, 인터페이스를 통해 **다중 상속**을 지원합니다.
  - **플랫폼 독립성:** 자바는 **"한 번 작성, 어디서나 실행"**의 철학을 가지고 있으며, **다양한 플랫폼에서 동일한 바이트코드**를 실행할 수 있습니다.

- **파이썬 (Python):**
  - **동적 타이핑 (Dynamic Typing):** 파이썬은 **동적 타입 언어**로, 변수의 타입을 **런타임**에 정의합니다. 이는 **코딩을 더 유연하게** 만들어 줍니다.
  - **인터프리터 언어:** 파이썬 코드는 **인터프리터**에 의해 **실행**되며, **바로 실행**할 수 있습니다.
  - **다중 패러다임:** 파이썬은 **객체 지향, 절차적**, **함수형 프로그래밍**을 지원하며, 다양한 프로그래밍 스타일을 사용할 수 있습니다.
  - **GIL (Global Interpreter Lock):** 파이썬은 **GIL**을 사용하여 **멀티스레딩**의 성능이 제한적입니다. **병렬 처리**에는 주로 **멀티프로세싱**을 사용합니다.
  - **다중 상속 지원:** 파이썬은 **클래스의 다중 상속을 지원**하며, MRO (Method Resolution Order)를 통해 **메소드 해결**을 관리합니다.
  - **편리한 문법:** 파이썬은 **읽기 쉬운 문법**과 **다양한 내장 함수**를 제공하여 **빠른 개발**이 가능합니다.

**자바와 파이썬의 차이**를 요약하면, 자바는 **정적 타이핑과 컴파일 언어**, **플랫폼 독립성**을 강조하며, 파이썬은 **동적 타이핑과 인터프리터 언어**, **다양한 프로그래밍 패러다임**을 지원합니다.

**JavaScript(JS)와 TypeScript(TS)의 차이:**

- **JavaScript (JS):**

  - **동적 타이핑:** JavaScript는 **동적 타입 언어**로, 변수의 타입을 **런타임**에 결정합니다.
  - **인터프리터 언어:** 브라우저에서 **직접 실행**되며, **동적**으로 실행됩니다.
  - **프로토타입 기반:** 객체 지향 프로그래밍에서 **클래스가 아닌 프로토타입 기반**의 상속을 사용합니다.
  - **JavaScript 표준:** **ECMAScript** 표준을 따릅니다.

- **TypeScript (TS):**
  - **정적 타이핑:** TypeScript는 **정적 타입 언어**로, **컴파일 타임**에 타입 검사를 수행합니다.
  - **컴파일 언어:** TypeScript는 **자바스크립트로 컴파일**되어 실행됩니다.
  - **클래스 기반:** TypeScript는 **클래스 기반 상속**을 지원하며, **자바스크립트의 문법**을 확장합니다.
  - **타입 시스템:** **타입 주석**을 통해 변수와 함수의 타입을 명시할 수 있습니다.

**C와 C++의 차이:**

- **C:**

  - **절차적 프로그래밍:** C는 **절차적 프로그래밍** 언어로, **함수 중심**의 프로그래밍을 지원합니다.
  - **저수준 언어:** **저수준 메모리 조작**을 지원하며, 하드웨어와의 밀접한 작업이 가능합니다.
  - **단순성:** **단순하고 명확한 문법**을 가지고 있습니다.

- **C++:**
  - **객체 지향 프로그래밍:** C++는 **객체 지향 프로그래밍**을 지원하며, **클래스와 객체**를 사용하여 **코드를 구조화**할 수 있습니다.
  - **템플릿:** **제네릭 프로그래밍**을 지원하며, **템플릿**을 통해 **타입에 독립적인 코드**를 작성할 수 있습니다.
  - **다중 패러다임:** C++는 **객체 지향, 제네릭**, **절차적 프로그래밍**을 지원합니다.

**기타 언어와의 차이:**

- **파이썬과 자바:** 파이썬은 **동적 타입**과 **인터프리터** 언어, 자바는 **정적 타입**과 **컴파일** 언어입니다.
- **C와 C++:** C는 **절차적 프로그래밍** 언어, C++는 **객체 지향**과 **제네릭 프로그래밍**을 지원합니다.

결론적으로, 각 언어는 **특징과 장단점**이 있으며, **프로젝트의 요구사항**에 따라 적절한 언어를 선택하는 것이 중요합니다.

</details>

---

답변이 도움이 되었기를 바랍니다. 추가적인 질문이나 더 궁금한 점이 있으면 언제든지 물어보세요!
